\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[english, russian]{babel}
\usepackage{amsfonts, amsmath, amssymb, amsthm, array, hhline, epsfig, graphicx}
\usepackage{mathtext}
\usepackage[a4paper,hmargin=15mm,vmargin=20mm]{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}
\usepackage{graphicx}
\usepackage{pgfplots}
\usepackage[unicode, pdftex]{hyperref}

% More styles for bullets
\usepackage{pifont}

%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  % backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

%"mystyle" code listing set
\lstset{style=mystyle}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{statement}{Утверждение}
\newtheorem{definition}{Определение}%[section]

\title{Hopcroft realization}
\author{Андрей Ратьков}
\date{Ноябрь 2023}

\begin{document}
\begin{center}
  \hfill \break
  \footnotesize{ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ}\\ 
  \footnotesize{ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ}\\
  \footnotesize{«САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ»}\\
  \footnotesize{(СПбГУ)}\\
%  \small{\textbf{«САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ»}}\\
  \hfill \break
  \normalsize{Образовательная программа бакалавриата «Науки о данных»}\\
  \hfill \break
  \hfill \break
  \begin{center}
    \includegraphics[width=7cm]{eagle.png}
  \end{center}
  \large{Отчёт по практике}\\
  \large{«Учебная практика (проектно-технологическая практика)»}\\
  \hfill\break
  \hfill \break
  \hfill \break
  \hfill \break
  \hfill \break
\end{center}
\begin{flushright}
  Выполнил студент 2 курса бакалавриата\\
  (группа 22.Б05-мкн)\\
  Ратьков Андрей Игоревич\\
  \hfill \break
  \hfill \break
  Научный руководитель:\\
  д.ф.-м.н. Охотин Александр Сергеевич\\
  \hfill \break
  \hfill \break
  \hfill \break
  \hfill \break
\end{flushright}
\begin{center}
  \hfill \break
  \hfill \break
  \hfill \break
  \hfill \break
  \hfill \break
  Санкт-Петербург\\
  2024
\end{center}
\clearpage
% \begin{abstract}
%     abobus
% \end{abstract}
\tableofcontents \newpage
\section{Описание алгоритма Хопкрофта}
\subsection{Вступление}
На входе подаётся детерминированный конечный автомат (DFA) $A$($\Sigma$, $Q$, $q_0$, $\delta$, $F$). $\Sigma$ --- входной алфавит --- конечный набор символов, $Q$ --- конечное множество состояний, $q_0 \in Q$ --- начальное состояние, $\delta: Q \times \Sigma \longrightarrow Q$ --- правила переходов, $F \subset Q$ --- множество принимающих состояний. Алгоритм минимизации преобразует автомат $А$ до нового минимального автомата $A'$ (автомата с минимальным числом состояний), распознающего тот же язык.

Для начала удаляются состояния, в которые нельзя попасть из начального состояния $q_0$. Остальные состояния разбиваются на классы эквивалентности по следующему отношению:

\begin{definition}
Состояния $q_1$ и $q_2$ \textbf{эквивалентны} ($q_1 \sim q_2$), если множество слов, принимаемых из состояния $q_1$ равно множеству слов, принимаемых из состояния $q_2$.
\end{definition}

По теореме Мура, получаемый при этом автомат минимальный. Алгоритм Мура минимизации конечных автоматов работает за время $O(n^2)$, где $n = |Q|$ --- количество состояний в исходном автомате $A$. Ниже будет расмотрен алгоритм Хопкрофта \cite{hopcroft1971n}, делающий то же самое, но с лучшей асимптотикой $O(n \log n)$.
\subsection{Используемые объекты и подготовка к минимизации}
Первым делом покажем, что удаление недостижимых из $q_0$ состояний можно сделать линейно. Будем красить состояния в три цвета: черный, серый, белый. Белый будет означать, что алгоритм не достиг ещё этого состояния, серый --- достиг, но не прошёл из него в соседние состояния (т.е. в состояния, в которые можно попасть из текущего по какому-то символу), чёрный --- что состояние посещено и достигнуты соседние с ним состояния. В начале алгоритм красит начальное состояние в серый, остальные --- в белый, начальное состояние кладёт в очередь (очередь состоит из серых состояний). Далее, пока очередь непуста, из неё берется серое состояние, перекрашивается в чёрный. Перебираются его соседние состояния, и те из них, которые белые, перекрашиваются в серый и добавляются в очередь. Работает это за время $O(|\Sigma| n)$, так по каждому из рёбер графа, задаваемом A, алгоритм пройдёт не более 1 раза, сделает не более $n$ добавлений и вытаскивний элемента из очереди (каждая из этих операций --- $O(1)$).

В реализации алгоритма понадобится отображение $\delta^{-1}: Q \times \Sigma \longrightarrow 2^{Q}$: каждому состоянию $q \in Q$ и символу $a \in \Sigma$ сопоставляется множество состояний, из которых можно прийти в $q$ по $a$ ($\delta^{-1}(q, a) = \{s \in Q | \delta(s, a) = q\}$). Поскольку 
\[ \sum_{q \in Q} \sum_{a \in A} \delta^{-1}(q, a) = |\Sigma|n\] (обе части --- количество переходов в графе, задаваемом A), для $\delta^{-1}$ построение занимает $O(|\Sigma| n)$ времени и $O(|\Sigma| n)$ памяти.

Как и в алгоритме Мура, алгоритм Хопкрофта будет разбивать состояния автомата A на блоки (раскрашивать состояния в цвета), пока в конце не окажется, что разбиение на блоки (цвета) не удовлетворяет следующему условию: два состояния находятся в одном блоке (помечены одним цветом) тогда и только тогда, когда они эквивалентны. Тогда будет получено искомое разбиение на классы эквивалентности.

На каждой итерации алгоритма все состояния покрашены в k цветов (разбиты на k блоков). Блоки будем обозначать $B(0)$, $B(1)$, \dots, $B(k - 1)$. Чтобы быстро уметь итерироваться (перебирать все элементы) по какому-нибудь блоку $B(j)$, будем представлять, что состояния находятся в каком-то порядке и для каждого состояния мы храним номер следующего состояния такого же цвета и предыдущего состояния такого же цвета. Также для каждого цвета $j$ удобно хранить первое состояние цвета $j$ (обозначим его за $first(j)$). Тогда проитерироваться по всем состояниям $B(j)$ несложно: для начала обращаемся к состоянию $first(j)$, а затем из состояния идём в следующее состояние этого цвета (пока не достигнем последнего состояния в блоке). При такой конструкции итерирование по всякому блоку $B(j)$ (перебор всех состояний из $B(j)$) занимает $O(|B(j)|)$ времени.

Также для каждого цвета $j$ и символа $a$ будем помнить множество всех состояний цвета $j$, в которые можно попасть по символу $a$. Будем обозначать это множество как $\hat B(B(j), a)$. Нам понадобится итерироваться по таким множествам $\hat B(B(j), a)$. Можно считать, что состояния в каждом множестве $\hat B(B(j), a)$ --- элементы двусвязного списка. А именно, для каждого состояния $q \in B(j)$, для каждого символа $a$, если в $q$ можно попасть по $a$, будем хранить номер следующего состояния из $\hat B(B(j), a)$ и предыдущего (если таковые есть). Также для каждого множества $\hat B(B(j), a)$ будем хранить первого состояния из этого множества (обозначим его за $first(j, a)$). Тогда итерирование по множеству $\hat B(B(j), a)$ выглядит так: сначала обращаемся к $first(j, a)$, а затем из состояния переходим к следующему, которое лежит в $\hat B(B(j), a)$ (пока можем перейти, то есть пока следующее есть). При такой конструкции итерирование по состояниям из всякого множества $\hat B(B(j), a)$ занимает $O(|\hat B(B(j), a)|)$ времени.

На каждом этапе алгоритма мы будем поддерживать, что если у состояний разный цвет (они в разных блоках), то из них принимаются разные языки. То есть для всяких блоков $B(i), B(j), \ (i \neq j)$, для любых двух состояний из них $q_1 \in B(i)$, $q_2 \in B(j)$ существует разделяющая строка $w \in \Sigma^*$ (то есть такая, $w$  --- принимаемая из $q_1$, но не принимаемая из $q_2$, или наоборот --- принимаемая из $q_2$, но не принимаемая из $q_1$). Например, в начале все принимающие состояние покрашены в цвет 0 (блок $B(0)$), отвергающие --- в цвет 1 (блок $B(1)$). Разделяющая строка для этих блоков --- $\epsilon$.

\subsection{Несколько утверждений}
\begin{lemma} Пусть все состояния разбиты на блоки: из состояний разных блоков принимаются разные языки. Зафиксируем блок $B(i)$ и символ $a \in \Sigma$. Рассмотрим произвольный блок $B(j)$. Определим \[B'(j) = \{ t \in B(j) | \delta(t, a) \in B(i)\},\]
\[B''(j) = \{ t \in B(j) | \delta(t, a) \notin B(i)\}.\]
Тогда $\forall q_1 \in B'(j) \ \forall \ q_2 \in B''(j)$ из состояний $q_1$ и $q_2$ принимаются разные языки, то есть $q_1 \not \sim q_2$.
\end{lemma}
\begin{proof}
Пусть $p_1 = \delta(q_1, a)$. $p_1 \in B(i)$, так как $q_1 \in B'(j)$. Пусть $p_2 = \delta(q_2, a)$. $p_2 \not \in B(i)$, так как $q_2 \in B''(j)$.

Состояния $p_1$ и $p_2$ лежат в разных блоках, поэтому существует строка $w$, принимаемая ровно из одного из них. Тогда строка $aw$ принимается ровно из одного из состояний $q_1, q_2$ ($w$ принимается из $p_1 \Longleftrightarrow aw$  принимается из $q_1$; $w$ принимается из $p_2 \Longleftrightarrow aw$  принимается из $q_2$).
\end{proof}
Отсюда понятно, что если блок $B(j)$ заменить на блоки $B'(j)$ и $B''(j)$ (если они оба непусты), то по-прежнему в новом разбиении на блоки выполнено, что состояния в разных блоках неэквивалентны.
\begin{definition}
    Пусть все состояния разбиты на $k$ блоков $B(0), B(1), \dots, B(k - 1)$, зафиксирован блок $B(i)$ и символ $a \in \Sigma$. Для каждого блока $B(j)$ определим множества $B'(j)$ и $B''(j)$ как в теореме выше. Получим новое разбиение: для каждого $j \in \{0, \dots, k - 1\}$, если оба множества $B'(j)$ и $B''(j)$ непусты, заменим блок $B(j)$ на блоки $B'(j)$ и $B''(j)$, тем самым получим новое разбиение  на блоки --- измельчение старого разбиения. Такую операцию измельчения разбиения состояний на блоки будем называть \textbf{измельчением с помощью блока $\textbf{B}(\textbf{i})$ и символа $\textbf{a}$}. Измельчение будем называть \textbf{бесполезным}, если оно не увеличивает число блоков (для всякого блока $B(j)$ один из блоков $B'(j)$ и $B''(j)$ пуст), или \textbf{полезным} в противном случае.
\end{definition}
Суть алгоритма --- сначала разбить состояние на два блока (принимающие и отвергающие состояния). А дальше много раз измельчать разбиение: выбирать какой-то блок $B(i)$ и какой-то символ $a$ и измельчать с помощью них.
\begin{statement} Каждый блок состоит либо только из принимающих состояний, либо только из отвергающих.
\end{statement}
\begin{proof}
Индукция по количеству блоков. База: 2 блока: $B(0)$ --- все принимающие состояния, $B(1)$ --- все отвергающие. Переход: количество блоков увеличивается, когда какой-то блок разбивается на два других. Поскольку разбиваемый блок состоял только из принимаемых состояний или только из отвергающих, то и новые два блока тоже.
\end{proof}
\begin{statement} Если до какого-то измельчения любые два эквивалентных состояния находились в одном блоке, то и после измельчения тоже.
\end{statement}
\begin{proof}
Пусть эквивалентные состояния $q_1$ и $q_2$ находятся в блоке $B(j)$ и происходит измельчение по блоку $B(i)$ и символу $a$. Возможны два варианта: либо оба $\delta(q_1, a)$ и $\delta(q_2, a)$ лежат в $B(i)$, тогда $q_1$ и $q_2$ лежат в $B'(j)$, либо оба $\delta(q_1, a)$ и $\delta(q_2, a)$ не лежат в $B(i)$, тогда $q_1$ и $q_2$ лежат в $B''(j)$. Третий вариант, когда только одно из $\delta(q_1, a)$ и $\delta(q_2, a)$ лежит в $B(i)$, не достигается: тогда, по теореме 1, $q_1$ и $q_2$ неэквивалентны --- противоречие.
\end{proof}
\begin{lemma}
Пускай все состояния разбиты на непустые блоки, причём для всякого блока $B(i)$ и символа $a \in \Sigma$ верно, что измельчение по блоку $B(i)$ и символу $a$ бесполезно. Тогда состояния внутри каждого блока эквивалентны. 
\end{lemma}
\begin{proof}
Предположим, что существуют пары состояний $q_1$ и $q_2$ лежащих в одном блоке, которые неэквивалентны. Каждой такой паре сопоставим кратчайшую разделяющую строку. Понятно, что каждая разделяющая строка не является пустой: тогда бы одно из состояний было бы принимающим, а другое нет, что противоречило бы утверждению 1.

Рассмотрим пару неэквивалентных состояний $q_1$ и $q_2$ из какого-то блока, которым была сопоставлена самая короткая строка (назовём её $w$). Как мы уже выяснили, $w$ непуста, а значит представима в виде $w = au, a \in \Sigma, \ u \in \Sigma^*$. Рассмотрим $p_1 = \delta(q_1, a)$ и $p_2 = \delta(q_2, a)$. Состояния $p_1$ и $p_2$ лежат в одном блоке (это следует из условия теоремы: если это не так, то измельчение по блоку, содержащему одно из них и по символу $a$ будет полезным --- после него $q_1$ и $q_2$ окажутся в разных блоках, противоречие).

% Если $u = \epsilon$, то они оба принимаются/отвергаются по лемме 1, тогда оба состояния $q_1$ и $q_2$ принимаются/отвергаются по строке $w = a$, а значит $w$ --- не разделяющая, противоречие. Теперь если $u$ не пустая.
Если $u$ является разделяющей для состояний $p_1$ и $p_2$, то возникает противоречие с выбором пары $q_1, q_2$ и строки $w$ --- кратчайшей разделяющей строки ($|u| < |w|$). Иначе, оба $p_1$ и $p_2$ принимаются/отвергаются по строке $u$. Тогда оба состояния $q_1$ и $q_2$ принимаются/отвергаются по строке $w=au$, а значит она неразделяющая, противоречие.
\end{proof}
Алгоритм измельчает разбиение, пока может: пытается найти блок $B(i)$ и символ $a$, измельчение с помощью которых полезно. Понятно, что он завершается, так как количество блоков в конце станет не более $n$, а значит полезных измельчений случится не более чем $n - 2$. По утверждению 2 если какие-то состояния эквивалентны, то они всегда будут оставаться в одном блоке и, следовательно, в конечном разбиении они тоже будут лежать в одном блоке. По лемме 2, если два состояния неэквивалентны, то после завершения алгоритма они будут лежать в разных блоках. 
\begin{lemma}
    Пусть состояния разбиты на блоки и происходит измельчение с помощью блока $B(i)$ и символа $a \in \Sigma$. Далее происходит сколько-то каких-то других измельчений, и оказывается, что получилось новое измельчение, в котором блок $B(i)$ заменился на $m \ge 1$ блоков $B(i_1), \dots, B(i_m)$ и произошли измельчения по блокам $B(i_1), \dots , B(i_{m - 1})$ и символу $a$. Тогда, после этого, измельчение по блоку $B(i_m)$ и символу $a$ бесполезно.
\end{lemma}
\begin{proof}
    Рассмотрим произвольный блок $B(l)$, в котором есть состояние $s \in B(l)$, из которого по $a$ можно попасть в блок $B(i_m)$ ($\delta(s, a) \in B(i_m)$). Покажем, что тогда из всех состояний блока $B(l)$ по $a$ можно попасть в $B(i_m)$. Рассмотрим произвольное состояние: $t \in B(l)$.

    Пусть $B(k)$ --- блок, в который из $t$ можно попасть по $a$. Если $k \in \{i_1 \dots, i_{m-1}\}$ (по блоку $B(k)$ и символу $a$ было измельчение), то состояния $s$ и $t$ и до, и после измельчения по блоку $B(k)$ и символу $a$ оставались внутри одного блока, хотя ровно из одного из них по $a$ можно попасть в $B(k)$ --- противоречие. Если $k \notin \{i_1, \dots, i_m\}$, то состояния $s$ и $t$ и до, и после измельчения по блоку $B(i)$ и символу $a$ оставались в одном блоке, хотя ровно из одного из них по $a$ можно было попасть в $B(i)$ по символу $a$ --- противоречие.
\end{proof}
% draw an illustration!!!
Алгоритм будет хранить для каждого $a \in \Sigma$ множество $L(a)$ номеров блоков, из которых впоследствии будет выполняться измельчение по символу $a$.

Алгоритм такой. В начале для всякого $a \in \Sigma$ определяем $L(a) = \{\}$. Это множество номеров блоков, с помощью которых и символа $a$ будут происходить измельчения. После разделения состояний на два блока --- $B(0)$ (принимающие) и $B(1)$ (отвергающие), для каждого $a \in \Sigma$ в $L(a)$ добавляем $0$, если $|\hat B(B(0), a)| \le |\hat B(B(1), a)|$, иначе $1$. Пока не все $L(a)$ пусты, алгоритм берёт и вытаскивает какой-то номер блока $i$ из какого-то $L(a)$. Для всех $B(j)$ алгоритм, если оба множества $B'(j)$ и $B''(j)$ из теоремы 1 непусты, делит $B(j)$ на два новых блока $B(j_1) = B'(j)$ и $B(j_2) = B''(j)$. Для всякого символа $c \in \Sigma$ если в $L(c)$ был блок $B(j)$, теперь вместо него будут оба блока $B(j_1)$ и $B(j_2)$, иначе туда добавится ровно один из них: если $|\hat B(B(j_1), a)| \le |\hat B(B(j_2), a)|$, то $B(j_1)$, иначе $B(j_2)$. Таким образом шаблон алгоритма выглядит так:
%\clearpage
\hypertarget{pseudocode}{\subsection{Псевдокод}}
\begin{algorithm}
%  \caption{An algorithm with caption}\label{alg:cap}
  \begin{algorithmic}[1]
  %\Require $n \geq 0$
  %\Ensure $y = x^n$
  % \State $y \gets 1$
  % \State $X \gets x$
  % \State $N \gets n$
  \While{$\exists a: L(a) \ne \emptyset$}
  \label{line1}
  % \hypertarget{line2}{\State{select $a$ and $i \in L(a)$, delete $i$ from $L(a)$}}
  \State{select $a$ and $i \in L(a)$, delete $i$ from $L(a)$}
  \label{line2}
  \For{all blocks $B(j)$}  
    \If{$\exists t \in B(j): \delta(t, a) \in B(i)$}
    \Comment{We need to divide this block into 2 blocks}
      \State{divide $B(j)$ into $B'(j) = \{t \in B(j) | \delta(t, a) \in \hat B(B(i), a)\}$}
      \label{line5}
      \State{and $B''(j) = \{t \in B(j) | \delta(t, a) \notin \hat B(B(i), a)\}$}
      \label{line6}
      \State{let $k$ be a number for a new block}
      \State{$B(j) = B'(j)$, $B(k) = B''(j)$}
      \label{line8}

      \For{$c \in \Sigma$}
        \If{$j \in L(c)$}
          \label{line10}
          \State $L(c)$.add($k$)
          \label{line11}
          \ElsIf{$|\hat B(B(j), c)| \le |\hat B(B(k), c)|$}
          \label{line12}
          \State $L(c)$.add($j$)
          \label{line13}
        \Else
          \State $L(c)$.add($k$)
          \label{line15}
        \EndIf
        \label{line16}
      \EndFor
    \EndIf
  \EndFor
  \EndWhile
  \end{algorithmic}
\end{algorithm}
Написанный выше псевдокод несложно улучшить по асимптотике, используя уже построенные структуры. Во-первых, на каждой итерации алгоритма (при каждом измельчении), создадим множество $R$, состоящее из номеров блоков, которые надо разделить. Для этого в начале нужно его инициализировать $R = \{\}$, а дальше для всякого $t: \delta(t, a) \in B(i)$ добавим в $R$ номер блока, в котором лежит $t$. То есть, это делается за $O(|\{t | \delta(t, a) \in B(i)\}|)$ -- просто проходимся по состояниям из множества $\delta^{-1}(B(i))$.

Посмотрим на каждый блок, который разделяется на два непустых блока. Пусть у исходного блока был номер $j$, у новых будут номера $j$ и $f(j)$. Посмотрим, каких состояний в исходном блоке меньше: тех, из которых можем попасть в $B(i)$ по $a$, или тех, по которым не можем. Меньшую из этих частей перенесём в блок $B(f(j))$. Перенос одного состояния занимает $O(|\Sigma|)$ времени, так как для каждого состояния мы храним указатели на следующее и предыдущее состояния из этого же блока, а также (для каждого $a \in \Sigma$, если в состояние можно попасть по символу $a$) указатели на следующее и предыдущее состояние этого же блока, в которые можно попасть по $a$, эту информацию нужно обновить. Такое размышление поможет в лемме \ref{lemma5}.

% Для каждого номера $j$ из $R$ обозначим за $f(j)$ номер нового блока, в который мы перенесём состояния блока $B(j)$, из которых по $a$ можно попасть в $B(i)$. То есть блок $B(j)$ разделится на блоки $B(j)$ и $B(f(j))$. При этом, возможно, блок $B(j)$ после этого останется пустым (в случае, если до разделения блока $B(j)$ из всех его состояний по $a$ можно было попасть в $B(i)$).

% Далее будем снова проходить по состояниям $t: \delta(t, a) \in B(i)$ и менять номер блока каждого из них (если он был $j$, то станет $f(j)$). Также, поскольку для каждого блока мы храним $|B(j)|$ и $|\hat B(B(j), a)|$, будем поддерживать изменения этих параметров для блоков $B(j)$ и $B(f(j))$. И, ещё, поскольку для каждого состояния мы храним указатели на следующее и предыдущее состояния из этого же блока, а также (для каждого $a \in \Sigma$, если в состояние можно попасть по $a$) указатели на следующее и предыдущее состояние этого же блока, в которые можно попасть по $a$, эту информацию нужно тоже обновить. В общем, всю $O(|\Sigma|)$ информацию, которую мы храним в каждом состоянии, нужно будет поменять. Это можно сделать за время $O(|\Sigma|)$ (поскольку у нас двусторонние списки, вставка в конец и вытаснивание элемента делаются за $O(1)$).

Для всякого блока $B(j)$ из него вытащатся либо состояния $\{t \in B(j) | \delta(t, a) \in B(i)\}$, либо состояния $\{t \in B(j) | \delta(t, a) \notin B(i)\}$ (смотря в каком множестве меньше элементов). Значит, из блока $B(j)$ будет вытащено не более $|\{t \in B(j) | \delta(t, a) \in B(i)\}|$ элементов. Итого, одна итерация внешнего цикла while (строка ~\ref{line1} псевдокода) занимает $O(|\Sigma|\cdot|\{t | \delta(t, a) \in B(i)\}|)$ времени.

\subsection{Корректность алгоритма}
\begin{lemma}
  Алгоритм, описанный выше, корректен.
\end{lemma}
\begin{proof}
  Достаточно показать, что для любых состояний $q_1, q_2 \in Q$, если $q_1 \sim q_2$, то $q_1$ и $q_2$ лежат в одном блоке, иначе в разных.

  Первое следует из утверждения 2: действительно, в начальном разбиении на $B(0)$ и $B(1)$, если пара состояний эквивалентны, то оба лежат в одном блоке, а далее, в ходе измельчений, они будут продолжать лежать в одном блоке.

  Теперь покажем, что если состояния неэквивалентны, то они окажутся в разных блоках. Предположим, что существуют пары состояний $q_1$ и $q_2$ такие что $q_1 \not \sim q_2$ и при этом они лежат в одном блоке $B(i)$ в конце работы алгоритма. Каждой паре таких состояний сопоставим кратчайшую разделяющую их строку.

  Среди всех таких пар состояний $q_1$ и $q_2$ выберем ту, для которой сопоставленная кратчайшая строка является самой короткой. Пусть теперь это пара $p_1$ и $p_2$, а кратчайшая разделяющая их строка --- $w \in \Sigma^*$.

  Поскольку $p_1$ и $p_2$ лежат в одном блоке $B(i)$, они либо оба принимающие, либо оба отвергающие, значит, всякая разделяющая их строка имеет положительную длину. Пусть $a$ --- первый символ строки $w$: $w = au$, где $u \in \Sigma^*$.

  Пусть $r_1 = \delta(p_1, a), r_2 = \delta(p_2, a)$. Блок, в котором находится состояние $r_1$, назовём $B(j_1)$, а в котором находится состояние $r_2$ --- $B(j_2)$.

  Заметим, что $j_1 \neq j_2$: иначе, если $j_1$ = $j_2$, то получится, что $r_1$ и $r_2$ --- состояния из одного блока, и при этом они неэквивалентны ($u$ --- разделяющая их строка). Тогда у этой пары состояний кратчайшая строка короче ($|u| < |w|$) --- противоречие с выбором $p_1$ и $p_2$.

  Рассмотрим итерацию алгоритма, после которой состояния $r_1$ и $r_2$ оказались в разных блоках, пусть это блоки $B(l_1)$ и $B(l_2)$. После этого не менее, чем одно из чисел $l_1, l_2$ было помещено в $L(a)$. Не умаляя общности, будем считать, что это $l_1$. Начиная с этого момента, состояние $r_1$ находилось в одном из блоков, упомянутых в списке $L(a)$. Поскольку алгоритм завершился после того, как список $L(a)$ опустел, был хотя бы один момент, когда из $L(a)$ вытащили номер $m$ блока, содержащего состояние $r_1$ ($r_1 \in B(m)$). Рассмотрим такой момент.

  Происходит измельчение по блоку $B(m)$ и символу $a$. Отметим, что $r_1 \in B(m)$; $r_2 \notin B(m)$, так как $B(m) \subset B(l_1)$ и $r_2 \notin B(l_1)$. Тогда получается, что
  \[\delta(p_1, a) = r_1 \in B(m)\]
  \[\delta(p_2, a) = r_2 \notin B(m)\]
  Состояния $p_1$ и $p_2$ находятся в одном блоке. Значит, после измельчения, они должны оказаться в разных блоках. Тогда и по завершении алгоритма они будут в разных блоках. Противоречие.
\end{proof}
\subsection{Асимптотика алгоритма}
\begin{statement}
  Пусть $a \in \Sigma$, $q \in Q$. За всю работу алгоритма, из $L(a)$ извлекался номер блока, содержащего состояние $q$, не более $\log(n)$ раз.   
\end{statement}
\begin{proof}
  Пусть $k$ --- количество раз, когда из $L(a)$ извлекался номер блока, содержащего $q$.

  Пусть $x_1$ --- размер этого блока при первом извлечении, $x_2$ --- при втором, и так далее, $x_k$ --- размер при последнем извлечении из $L(a)$. Покажем, что $\forall j < k: \ x_j \ge 2 \cdot x_{j+1}$.

  Рассмотрим $j$-ое извлечение. При нём состояние $q$ перестало находиться в каком-либо блоке, упомянутом в $L(a)$. После этого, в какой-то момент, в $L(a)$ был добавлен блок, содержащий $q$. Рассмотрим ближайший такой момент.

  Он соответствует \ref{line10} -- \ref{line16} строкам псевдокода (происходит $L(a).\text{add}(m)$, где $m$ --- номер блока, в котором находится состояние $q$ при этом добавлении). Это происходит после разделения блока (строки \ref{line5} -- \ref{line8}), в котором лежало состояние $q$ (пусть размер разделившегося блока $y_{j+1}$). При этом номер этого блока не находился в $L(a)$. Значит, добавлению соответствуют строки ~\ref{line12} -- ~\ref{line15} псевдокода (то есть из двух образовавшихся блоков добавили только наименьший). Таким образом, справедливо:
  \[x_j \ge y_{j+1} \ge 2 \cdot x_{j+1} \Rightarrow x_j \ge 2 \cdot x_{j+1}\]
  Аналогично можно отметить, что $x_1 \le n / 2$, так как $2 \cdot x_1 \le y_1 \le n$.

  Отсюда следует, что \[n/2 \ge x_1 \ge 2^{k-1} \cdot x_k\]
  Откуда, поскольку $x_k \ge 1$, $n \ge 2^k \Leftrightarrow k \le \log(n)$. 
\end{proof}
\begin{statement}
  Рассмотрим $t \in Q$. За всю работу алгоритма, состояние $t$ меняло блок (то есть извлекалось из старого блока в новый) не более $\log(n)$ раз.
\end{statement}
\begin{proof}
  При каждом извлечении состояния размер блока, в котором оно находится, уменьшается не менее чем в 2 раза, в начале этот размер не более чем $n$, в конце -- хотя бы 1, значит извлечений было не более чем $log(n)$.
\end{proof}

\begin{statement}
    Каждый образовавшийся в ходе алгоритма блок извлекался из $L$ не более чем $|\Sigma| \log(n)$ раз.
\end{statement}
\begin{proof}
    Действительно, рассмотрим какое-то состояние $t$, которое было в этом блоке до самого конца работы алгоритма. Тогда, по утверждению 3, наш блок извлекался из $L(a)$ не более чем $\log(n)$ раз для каждого $a \in \Sigma$. Значит, суммарно он извлекался не более чем $|\Sigma| \log(n)$ раз.
\end{proof}

Утверждение 3 можно немного усилить, и на основе этого потом получить хорошую оценку асимптотики количества извлечений блоков:
\begin{statement}
    Пусть при создании блок $B$ состоял из $M$ состояний, $a \in \Sigma$. Тогда из $L(a)$ блок $B$ извлекался не более чем $log(|M|) + 1$ раз.
\end{statement}
\begin{proof}
    В терминах доказательства утверждения 3 и аналогично ему, имеем:
    \[M \ge x_1 \ge 2^{k-1} \cdot x_k.\]
    Откуда, поскольку $x_k \ge 1$, $2 |M| \ge 2^k \Leftrightarrow k \le \log(|M|) + 1$. 
\end{proof}

\begin{lemma}
  \label{lemma5}
  Алгоритм, описанный выше, имеет временную асимптотику $O(|\Sigma|n\log(n))$.
\end{lemma}
\begin{proof}
  Удаление недостижимых из $q_0$ состояний, а также разбиение состояний на блоки $B(0)$ и $B(1)$, работают за линейное время, как было показано выше.

  Всего состояний $n$, значит, по утверждению 4, перемещений состояний из одного блока в новый, было всего не более $n \log(n)$. Одно перемещение занимает $O(|\Sigma|)$ времени (так как нужно поменять номер блока, в котором находится состояние, и, следовательно, информацию о том, какое следующее и предыдущее состояние в том же новом блоке, а также следующее и предыдущее состояния, в которые можно попасть по символу $c$ (для всех $c \in \Sigma$) --- это нужно для того, чтобы двусвязные списки оставались корректными).

  Итого, все перемещения состояний требуют $O(|\Sigma|n\log(n))$ времени.

  Осталось показать, сколько было добавлений и извлечений номеров блоков из $L$.

  Отметим, что можно в $L$ добавлять номера только непустых блоков (действительно, после этого извлекать номера пустых блоков бессмысленно --- измельчение с помощью них будет бесполезным). Итак, в $L$ добавляются только блоки положительного размера. % Всего за время работы алгоритма существовало не более чем $n$ блоков, для каждого, по утверждению 5, случилось не более чем $|\Sigma| \log(n)$ извлечений. Значит, за время работы алгоритма было не более чем $|\Sigma| n \log(n)$ извлечений. Каждое извлечение можно делать за $O(1)$, поскольку можно дополнительно поддерживать очередь или массив пар символов и номеров блоков $(a, j)$, по которым планируется измельчать.

  Покажем, что на самом деле вытаскивания блоков из $L$ было $O(|\Sigma|n)$. Пусть $k$ таково, что $2^{k - 1} \le n < 2^k$. Для каждого целого $0 \le s < k$ рассмотрим блоки, которые в момент создания имели размер в интервале $[2^s, 2^{s+1})$. Таких блоков не более чем $n / 2^s \le 2^{k-s}$. По утверждению 6, для всякого $c \in \Sigma$ каждый из таких блоков вытаскивается из $L(c)$ не более чем $s + 1$ раз. То есть в ходе всего алгоритма он вытаскивался не более чем $|\Sigma| \cdot (s + 1)$ раз. Итого, количество извлечений из $L$ всех блоков, размеры которых при создании были в интервале $(2^s, 2^{s+1}]$ оценивается сверху числом $|\Sigma| (s + 1) 2^{k-s}$. Остается просуммировать по $s$ от $0$ до $k - 1$.

  \[\sum_{s=0}^{k-1} |\Sigma| (s + 1) 2^{k-s} = |\Sigma| \cdot \sum_{s=0}^{k-1} (s + 1) 2^{k - s} \le |\Sigma| \cdot \sum_{s = 0}^{k - 1} (s + 1) \frac{2n}{2^s} < |\Sigma| \cdot 4n \sum_{s = 1}^{\infty} \frac{s}{2^s} < 8n |\Sigma|\]

  Каждое извлечение можно делать за $O(1)$, поскольку можно дополнительно поддерживать очередь или массив пар символов и номеров блоков $(a, j)$, по которым планируется измельчать. Итого, измельчения займут $O(|\Sigma| n)$ итераций.
  
%  Это значит, что в строках~\ref{line5}-\ref{line6} псевдокода перед этим произошло разбиение $B(j)$ на непустые $B'(j)$ и $B''(j)$. Поскольку блоков положительного размера не более чем $n$ в конце работы алгоритма, то разбиений блока на два непустых, случалось не более $n - 1$ раза за всю работу алгоритма. То есть в $L(c)$ добавляли (и, следовательно, извлекали) номера не более $n$ раз (для фиксированного $c \in \Sigma$). Значит, всего добавлений и извлечений номеров из $L$ было $O(|\Sigma| n)$ раз. Каждое добавление --- $O(1)$ по времени (добавление в конец списка: \ref{line11}, \ref{line13}, \ref{line15} строки псевдокода), каждое извлечение --- $O(|\Sigma|)$ времени (строка~\ref{line2} псевдокода), так как в ней нужно найти первый непустой список $L(a)$ и из него извлечь элемент.

  Итого, каждый вид действий, предпринимаемых алгоритмом, занимает не более чем $O(|\Sigma|n\log(n))$ времени. Значит, и алгоритм работает с асимптотикой $O(|\Sigma|n\log(n))$.

\end{proof}
Если считать, что $|\Sigma|$ --- некоторая константа, то асимптотика алгоритма Хопкрофта равна $O(n\log(n))$.
\section{Реализация алгоритма}
Проект реализован в нескольких файлах:
\begin{itemize}
  \item Директория \path{src/} --- содержит файлы реализаций функций и методов классов:
  \begin{itemize}
    \item[\ding{118}] \path{dfa_methods.cpp} --- реализация методов класса DFA.
    \item[\ding{118}] \path{nfa_methods.cpp} --- реализация методов класса NFA.
    \item[\ding{118}] \path{dfa_build.cpp} --- реализация функций обработки команд пользователя и инициализации DFA, исходя из этих команд.
    \item[\ding{118}] \path{main.cpp} --- работа с пользователем: получение DFA, его минимизация, вывод DFA.
  \end{itemize}
  \item Директория \path{include/} -- содержит заголовочные файлы.
  \begin{itemize}
    \item[\ding{118}] \path{dfa_class.h} --- объявление класса DFA.
    \item[\ding{118}] \path{nfa_class.h} --- объявление класса NFA.
  \end{itemize}
  \item Директория \path{obj/} --- содержит объектные файлы (скомпилированные \path{.cpp} файлы) --- создаётся при компиляции.
  \item Директория \path{test/} --- использовалась для тестирования, содержит \path{test.cpp} и \path{test.o} --- программа, принимающая на вход два DFA, минимизирующая их и хатем сравнивающая на равенство.
  \item Файл \path{minimizer} --- скомпилированный проект.
  \item \path{Makefile} --- файл для сборки.
\end{itemize}
Как собрать проект: зайти в главную директорию, запустить команду \lstinline[language=C++]!make!. Как запустить проект: запустить исполняемый файл \lstinline[language=C++]!minimizer! с несколькими аргументами (подробнее --- см. раздел~\ref{p1}).
\subsection{Класс DFA}
Сущность детерминированного конечного автомата как объекта реализована в классе \lstinline[language=C++]!class DFA!, который объявлен в файле \path{include/dfa_class.h}. Все состояния хранятся как числа в формате \lstinline[language=C++]!uint32_t! и могут принимать значения от 0 до $2^{32} - 2 = 4294967294$ (число UINT32\_MAX = 4294967295 зарезервировано как особое ''пустое'' состояние (\lstinline[language=C++]!EMPTY_STATE!), которое нужно для упрощения работы некоторых методов).

Основные поля класса \lstinline[language=C++]!class DFA! (заполняются при инициализации объекта):
\begin{itemize}
  \item \lstinline[language=C++]!uint32_t alphabet_length! --- длина рабочего алфавита.
  \item \lstinline[language=C++]!uint32_t size! --- размер автомата.
  \item \lstinline[language=C++]!std::vector<std::vector<uint32_t> > delta! --- правила переходов автомата. Элемент \lstinline[language=C++]![a][q]! --- состояние $\delta(q, a)$.
  \item \lstinline[language=C++]!std::vector<bool> acc! --- указывает, является ли принимающим каждое из состояний автомата.
  \item \lstinline[language=C++]!uint32_t starting_node! --- начальное состояние.
\end{itemize}
  Дополнительные поля класса \lstinline[language=C++]!class DFA! (используются при минимизации автомата):
\begin{itemize}
    \item \lstinline[language=C++]!std::vector<StateInfo> states_info! --- блоки информации для каждого состояния. Один блок информации (объект структуры \lstinline[language=C++]!struct StateInfo!) содержит следующую информацию о состоянии автомата:
    \begin{itemize}
      \item[\ding{118}] \lstinline[language=C++]!uint32_t block! --- номер блока, в котором находится состояние (его ''цвет'').
      \item[\ding{118}] \lstinline[language=C++]!uint32_t next_state_of_same_color! --- номер следующего состояния из того же блока.
      \item[\ding{118}] \lstinline[language=C++]!uint32_t prev_state_of_same_color! --- номер предыдущего состояния из того же блока.
    \end{itemize}
  
    \item \lstinline[language=C++]!std::vector<uint32_t> block2first_state_in_it! --- по номеру блока(цвета) сопоставляет первое состояние этого блока(цвета). То есть $i$-ый элемент показывает первое состояние в блоке $B(i)$.
  \item \lstinline[language=C++]!std::vector<std::vector<uint32_t> > block_and_char2first_B_cap! --- здесь элемент \lstinline[language=C++]![a][i]! показывает первое состояние в множестве $\hat B(B(i), a)$.
  \item \lstinline[language=C++]!std::queue<std::pair<uint32_t, uint32_t> > L! --- здесь лежат пары из индексов блоков и символов по которым будут измельчения.
  \item \lstinline[language=C++]!std::vector<std::vector<bool> > info_L! --- здесь элемент \lstinline[language=C++]![a][i]! принимает значение \lstinline[language=C++]!true!, если $i \in L(a)$, иначе принимает значение \lstinline[language=C++]!false!.
\end{itemize}
Следующие поля нужны для того, чтобы уметь быстро итерироваться и работать с множествами $\hat B(B(i), a)$:
\begin{itemize}
  \item \lstinline[language=C++]!std::vector<std::vector<uint32_t> > next_B_cap! --- здесь элемент \lstinline[language=C++]![a][i]! показывает, какое следующее состояние в том же блоке, что и $i$-ое состояние, тоже достижимо по символу $a$ (если $i$-ое состояние не достижимо по символу $a$ ни из какого другого состояния, то нам не важно, что там написано). Если $i$-ое состояние --- последнее в своём блоке, которое достижимо по символу $a$, то следующим считается ''пустое'' состояние (\lstinline[language=C++]!EMPTY_STATE!).
  \item \lstinline[language=C++]!std::vector<std::vector<uint32_t> > prev_B_cap! --- по аналогии, здесь элемент \lstinline[language=C++]![a][i]! показывает, какое предыдущее состояние в том же блоке, что и $i$-ое состояние, тоже достижимо по символу $a$.
  \item \lstinline[language=C++]!std::vector<std::vector<uint32_t> > B_cap_lengths! --- здесь элемент \lstinline[language=C++]![a][i]! --- это длина $|\hat B(B(i), a)|$.
\end{itemize}
Следующие поля нужны для того, чтобы построить $\delta^{-1}$ с небольшой константой по памяти и при этом чтобы итерирование по множеству состояний $\delta^{-1}(q, a)$ было быстрым ($O(|\delta^{-1}(q, a)|)$ времени):
\begin{itemize}
  \item \lstinline[language=C++]!std::vector<std::vector<uint32_t> > addresses_for_reversed_delta! --- элемент \lstinline[language=C++]![a][i]! показывает, с какого места в \lstinline[language=C++]!reversed_delta! начинается последовательность состояний, лежащих в множестве $\delta^{-1}(i, a)$.
  \item \lstinline[language=C++]!std::vector<uint32_t> reversed_delta! --- вектор состояний длины $n \cdot |\Sigma|$. Он устроен так, что список состояний из $\delta^{-1}(i, a)$ начинается с \lstinline[language=C++]!addresses_for_reversed_delta[a][i]!-го элемента и занимает длину \lstinline[language=C++]!reversed_delta_lengths[a][i]! ($i \in Q, a \in \Sigma$).
  \item \lstinline[language=C++]!uint32_t uint32_t colors! --- количество использованных цветов (номеров для блоков).
\end{itemize}
Следующие поля понадобятся для реализации одной итерации разбиения по блоку $B(i)$ и символу $a$:
\begin{itemize}
  \item \lstinline[language=C++]!std::unordered_map<uint32_t, info> blocks_info! --- разделяемым блокам сопоставляем \lstinline[language=C++]!info! --- количество отделяемых состояний и номер нового блока для них.
  \item \lstinline[language=C++]!std::vector<uint32_t> sep_blocks! --- список разделяемых блоков.
  \item \lstinline[language=C++]!std::vector<uint32_t> sep_states! --- список состояний, которые окажутся в новых блоках (то есть множество $\delta^{-1}(B(i), a)$), если происходит измельчение с помощью блока $B(i)$ и символа $a$.
\end{itemize}
Также в классе \lstinline[language=C++]!class DFA! доступны следующие методы (реализованы в файле \path{src/dfa_methods.cpp}):
\begin{itemize}
  \item[\ding{228}] \lstinline[language=C++]!void init(uint32_t _alphabet_length, uint32_t _size, uint32_t _starting_node, std::vector<std::vector<uint32_t> > &table, std::vector<bool> &v_acc)! --- инициализация автомата новыми значениями длины алфавита, размера, начального состояния, функции $\delta$ (\lstinline[language=C++]!table!) и информацией о принимающих/отвергающих состояниях (\lstinline[language=C++]!v_acc!).
  \item[\ding{228}] \lstinline[language=C++]!bool check_string(std::vector<uint32_t> &str)! --- проверяет, принимается ли строка \lstinline[language=C++]!str! или нет.
  \item[\ding{228}] \lstinline[language=C++]!void delete_unreachable_states()! --- удаление недостижимых состояний (делается в начале минимизации).
  \item[\ding{228}] \lstinline[language=C++]!void construct_reversed_delta()! --- строит \lstinline[language=C++]!reversed_delta_lengths!, \lstinline[language=C++]!addresses_for_reversed_delta!, \lstinline[language=C++]!reversed_delta!, используя функцию $\delta$.
  \item[\ding{228}] \lstinline[language=C++]!void color_acc_and_rej_in_2_colors()! --- выполняет первую итерацию алгоритма: красит все принимающие состояния в 0 цвет (0 блок), отвергающие --- в 1.
  \item[\ding{228}] \lstinline[language=C++]!bool minimize_iteration()! --- реализация одной итерации алгоритма Хопкрофта. Это самый важный метод в классе. Работает он так:
  \begin{enumerate}
    \item Поиск $a \in \Sigma$ такого, что $L(a)$ непусто, и выбор какого-нибудь блока $B(i)$ из $L(a)$.
    \item Проходимся по всем состояниям \lstinline[language=C++]!state_i! из $i$-го блока ($B(i)$), которые достижимы по символу $a$ (то есть, просто перебираем \lstinline[language=C++]!state_i! $\in \hat B(B(i), a)$).
    
    Перебираем \lstinline[language=C++]!sep_state! $\in \delta^{-1}($\lstinline[language=C++]!state_i!$, a)$. Для каждого блока будем поддерживать количество перебранных состояний в \lstinline[language=C++]!blocks_info!.

    \item Далее для каждого блока (для которого было перебрано хотя бы одно из состояний) смотрим на количество состояний в блоке и количество перебранных состояний их него. Если перебранных состояний больше половины, то отделять будем меньшую другую часть (просто итерируясь по всем состояниям блока и вытаскивая нужные состояния).
    
    \item Для состояний из оставшихся неразделенных блоков добавляем их в \lstinline[language=C++]!sep_states!, а таким блокам в \lstinline[language=C++]!blocks_info! указываем второй цвет. Затем проходимся по состояниям из \lstinline[language=C++]!sep_states! и отделяем их в нужные блоки.

  \end{enumerate}
  Функция возвращает значение \lstinline[language=C++]!true!, если итерация была последней и \lstinline[language=C++]!false!, если нет.
  \item[\ding{228}] \lstinline[language=C++]!void minimization(bool no_debug)! --- в ней происходит минимизация, и затем перестройка автомата: каждый блок становится одним состоянием. Аргумент \lstinline[language=C++]!bool no_debug! показывает, нужен ли вывод промежуточных резальтатов минимизации в stdout (\lstinline[language=C++]!false!, если да; \lstinline[language=C++]!true!, если нет). Схематично, функция работает так:
  \begin{lstlisting}[language=C++]
    void DFA::minimization(bool no_debug) {
      delete_unreachable_states();
      construct_reversed_delta();
      color_acc_and_rej_in_2_colors();

      bool finish = false;
      while (!finish) {
          finish = minimize_iteration();
      }

      /*dfa rebuilding*/
    }
  \end{lstlisting}
\end{itemize}
В частности, часть методов, нужная практически только для дебага:
\begin{itemize}
\item[\ding{228}] \lstinline[language=C++]!void print_table()! --- вывод таблицы $\delta$ в стандартный поток вывода stdout (если в DFA не более 50 состояний).
\item[\ding{228}] \lstinline[language=C++]!void print_current_classes_of_equality(bool finished, bool debug)! --- печатает текущее разбиение состояний на блоки в stdout.
\item[\ding{228}] \lstinline[language=C++]!uint32_t get_size()! --- возвращает размер DFA.
\item[\ding{228}] \lstinline[language=C++]!bool operator==(DFA& other)! --- проверяет DFA на равенство другому.
\end{itemize}
Также есть метод:
\begin{itemize}
  \item[\ding{228}] \hypertarget{p2}{\lstinline[language=C++]!int save_to_file(char* filename)!} --- сохранение DFA в бинарный файл, находящемуся по относительному пути, записанному в \lstinline[language=C++]!filename!. Сначала записываются три параметра \lstinline[language=C++]!size, alphabet_length, starting_node! --- количество состояний, размер алфавита и номер начального состояния, за тем $|\Sigma| \cdot n$ переходов. Далее записывается информация для каждого состояния, принимающее или отвергающаее оно (1 бит) --- это информация умещается в $[n/8] + 1$ байт. 
\end{itemize}
И несколько методов для инициализации (подробнее --- в разделе~\ref{p1}):
\begin{itemize}
  \item[\ding{228}] \lstinline[language=C++]!DFA(uint32_t _alphabet_length, uint32_t _size, uint32_t _starting_node, std::vector<std::vector<uint32_t>> &_delta, std::vector<bool> &_v_acc)! --- инициализация по всем заранее заданным полям.
  \item[\ding{228}] \lstinline[language=C++]!explicit DFA(char* command, char* dfa_str)! --- инициализация по двум строкам --- командам пользователя --- подробнее в разделе~\ref{p1}. Функция реализована в файле \path{src/dfa_build.cpp}. Она по двум аргументам от пользователя генерирует DFA (предварительно проверяя в функции \lstinline[language=C++]!request_check correctness_of_dfa_input(char* command, char* dfa_str))! корректность вводимых данных (возвращаемое значение \lstinline[language=C++]!request_check! --- пара булевого значения, показывающего, успешна ли проверка или нет и строки, в которой написана, какая ошибка, если она есть).
  \end{itemize}
\subsection{Класс NFA}
Класс, симулирующий недетерминированный конечный автомат, реализован в \lstinline[language=C++]!class NFA!, который объявлен в файле \path{include/nfa_class.h}. Объект этого класса имеет следующие поля:
\begin{itemize}
  \item \lstinline[language=C++]!uint32_t alphabet_length! --- длина рабочего алфавита.
  \item \lstinline[language=C++]!uint32_t size! --- размер NFA.
  \item \lstinline[language=C++]!std::vector<std::vector<std::vector<uint32_t> > > delta! --- функция недетерминированных переходов\\ $\delta: Q \times \Sigma \rightarrow 2^Q$.
  \item \lstinline[language=C++]!std::vector<uint32_t> starting_nodes! --- начальные состояния NFA.
  \item \lstinline[language=C++]!std::vector<bool> v_acc! --- информация о принимающих/отвергающих состояниях: элемент \lstinline[language=C++]![i]! равен \lstinline[language=C++]!true! тогда и только тогда когда $i$-ое состояние принимается.
\end{itemize}
И методы (реализованы в \path{src/nfa_methods.cpp}):
\begin{itemize}
  \item[\ding{228}] \lstinline[language=C++]!void init(uint32_t _alphabet_length, uint32_t _size, std::vector<std::vector<std::vector<uint32_t> > > &_delta, std::vector<uint32_t> &_starting_nodes, std::vector<bool> &_v_acc)! --- инициализация объекта заданными значениями всех полей.
  \item[\ding{228}] \lstinline[language=C++]!void print()! --- печатает NFA в stdout.
  \item[\ding{228}] \lstinline[language=C++]!DFA convert2dfa()! --- переводит NFA в DFA.
  \item[\ding{228}] \lstinline[language=C++]!uint32_t get_size()! --- возвращает размер NFA (количество состояний).
  \item[\ding{228}] \lstinline[language=C++]!bool line_complicated_initial_states()! --- \lstinline[language=C++]!true!, если начальные состояния заданы нетривиально, \lstinline[language=C++]!false!, если тривиально (то есть начальное состояние одно и оно --- 0-ое).
  \item[\ding{228}] \lstinline[language=C++]!std::string longline()! --- строковое представление длинных NFA (то есть размера более 61).
  \item[\ding{228}] \lstinline[language=C++]!std::string line()! --- строковое представление NFA.
  \item[\ding{228}] \lstinline[language=C++]!state_to_printable_character(int x)! --- переводит число от 0 до 61 в цифру или букву (нужно для метода \lstinline[language=C++]!line()!).
\end{itemize}
\subsection{Взаимодействие с пользователем} \label{p1}
Команды пользователя --- аргументы функции \lstinline[language=C++]!main()!. Если проект скомпилирован в файл \path{minimizer}, то запуск минимизации пользователем в командной строке может выглядить так:\\
 \lstinline[language=bash]!./minimizer from_bin_file binary_files/dfa0.bin -t -np!

 Первые два аргумента (в данном случае --- \lstinline[language=bash]!from_bin_file binary_files/dfa0.bin!) будем называть \lstinline[language=C++]!char* command! и \lstinline[language=C++]!char* dfa_str!. Через них однозначно задаётся автомат, который предстоит минимизировать. Первый аргумент --- \lstinline[language=C++]!command! --- задаёт тип инициализации DFA. Он может принимать следующие строковые значения:
 \begin{itemize}
  \item[\ding{82}] \lstinline[language=bash]!"from_dfa_string"! --- автомат инициализируется из строкового представления DFA, записанного в \lstinline[language=bash]!dfa_str!. Строковое представление DFA здесь имеет вид \lstinline[language=bash]!"010110...1_1a6Uy98..."!: сначала идёт $n$ нулей и единиц: $i$-ая из них означает, принимается ли $i$-ое состояние или отвергается. Затем идет разделитель \lstinline[language=bash]!"_"! и $|\Sigma| \cdot n$ состояний (состояние на $(j \cdot a + c)$-ом месте ($0 \le c < |\Sigma|$) --- состояние в которое идёт ребро из состояния $q_j$ по $c$-ому символу алфавита $\Sigma$). Все состояния кодируются либо цифрой, либо строчной или заглавной латинской буквой (таким образом, в этом случае их не более чем 62). Цифры кодируют первые 10 состояний, строчные буквы --- с 11-го по 36-ое, заглавные --- последние 26 состояний.
  \item[\ding{82}] \lstinline[language=bash]!"bamboo"! --- в таком случае в \lstinline[language=C++]!dfa_str! через запятую написан размер и количество символов в алфавите автомата. Сам автомат устроен так: для каждого символа $c\in \Sigma$ из $i$-го состояния по символу $c$ переход в $(i + 1)$-ое состояние (если $i$-ое состояние не последнее), иначе, если состояние последнее, то из него все переходы ведут в себя же. Принимается только последнее состояние. Несложно показать, что такой автомат при минимизации не уменьшается, однако алгоритм Мура на нём работает с асимптотикой $O(n^2)$ по времени, а алгоритм Хопкрофта --- за $O(n)$. Этот пример указан в статье Джона Хопкрофта \cite{hopcroft1971n}.
  \item[\ding{82}] \lstinline[language=bash]!"circle"! --- от автоматов предыдущего типа отличаются лишь тем, что из последнего состояния все переходы ведит не в себя, а в самое первое состояние. Для них верны те же утверждения про алгоритм Мура и Хопкрофта.
  \item[\ding{82}] \lstinline[language=bash]!"repeated_cycle"! --- односимвольный автомат, для которого параметры размер \lstinline[language=bash]!size! и длина цикла \lstinline[language=bash]!cycle_size! указываются через запятую в аргументе \lstinline[language=C++]!dfa_str! (при этом длина цикла --- делитель числа состояний!). Переходы тут такие же, как в DFA типа \lstinline[language=bash]!"circle"! --- из $i$-го состояния переход в состояние $(i + 1) \mod n$. Но принимающие состояния --- все, чьи номера равны $(n - 1)$ по модулю числа \lstinline[language=bash]!"cycle_size"!. Такой автомат минимизируется до цикла длины \lstinline[language=bash]!cycle_size!, в котором ровно одно принимающее состояние (последнее), а начальное состояние --- первое (то есть до автомата типа \lstinline[language=bash]!"circle"! размера \lstinline[language=bash]!cycle_size!).
  \item[\ding{82}] \lstinline[language=bash]!"from_bin_file"! --- чтение DFA из бинарного файла, путь к которому указан во втрором аргументе \lstinline[language=C++]!dfa_str!. Кодировка такая же, как в методе \hyperlink{p2}{\lstinline[language=C++]!int save_to_file(char* filename)!} класса DFA.
  \item[\ding{82}] \lstinline[language=bash]!"from_nfa_string"! --- сначала с помощью строки \lstinline[language=bash]!dfa_str! инициализируется NFA, который потом переводится в DFA. В строке \lstinline[language=bash]!dfa_str! NFA закодирован следующим образом. Для начала для каждого состояния пишутся множества состояний, в которые из него можно попасть по каждому из символов $\Sigma$. Если множество востоит не из 1 элемента, оно обособляется фигурными скобками. Если состояние начальное, перед тем, как писать его переходы, печатается символ \lstinline[language=bash]!">"!. Если символов \lstinline[language=bash]!">"! нет, то начальное состояние по умолчанию только одно --- первое. В конце идёт $n$ плюсов и минусов, $i$-ый плюс означает, что $i$-ое состояние принимающее, минус --- наоборот, отвергающее. Например, у NFA могут быть следующие кодировки: \lstinline[language=bash]!"{03}1{12}{}0{02}2{12}--+-"!, \lstinline[language=bash]!"{01}3>{12}{}0{02}>2{12}+++-"!.
 \end{itemize}
 Также пользователь может (но это необязательно) сохранить минимизированный DFA в какой-нибудь бинарный файл. Для этого третьим аргументов необходимо указать слово \lstinline[language=bash]!"save_to_bin_file"!, а четвёртым --- относительный путь к этому файлу.

 Также пользователь может указать в конце некоторые из следующих флагов:
 \begin{itemize}
  \item[\ding{100}] \lstinline[language=bash]!-t! --- если надо засекать время работы по минимизации автомата (потраченное время будет напечатано в stdout). 
  \item[\ding{100}] \lstinline[language=bash]!-nd, --no-debug! --- если не надо выводить в stdout информацию о успешном начале/конце минимизации и подобных действиях, а также количество состояний в минимизированном автомате. 
  \item[\ding{100}] \lstinline[language=bash]!-np, --no-print! --- если не надо в конце выводить в stdout новый минимизированный DFA. 
\end{itemize}
Примеры работы программы:

Минимизация автомата, данного в формате NFA, и сохранение его в бинарный файл:
\begin{lstlisting}[language=bash]
./minimizer from_nfa_string {03}1{12}{}0{02}2{12}--+- save_to_bin_file binary_files/dfa0.bin -t
DELETING UNREACHABLE STATES...
MINIMIZATION STARTED...
MINIMIZATION FINISHED SUCCESSFULLY
10 iterations happened
DFA UPDATED
It has 7 states now
Execution time: 0.000243977 seconds.
SIZE: 7  LEN_ALPHABET: 2 STARTING_NODE: 2
    |  0 |  1 | TYPE 
=====================
  0 |  0 |  0 | ACC
=====================
  1 |  0 |  5 | REJ
=====================
  2 |  1 |  6 | REJ
=====================
  3 |  1 |  0 | ACC
=====================
  4 |  4 |  4 | REJ
=====================
  5 |  0 |  3 | ACC
=====================
  6 |  5 |  4 | REJ
=====================
Saved successfully to binary file
\end{lstlisting}
Минимизация автомата из файла и сохранение в другой файл:
\begin{lstlisting}[language=bash]
./minimizer from_bin_file binary_files/dfa1.bin save_to_bin_file binary_files/dfa2.bin -t -np -nd
Execution time: 8.0964e-05 seconds.
\end{lstlisting}
Минимизация автомата типа \lstinline[language=bash]!"bamboo"!, состоящего из 1000000 состояний:
\begin{lstlisting}[language=bash]
./minimizer bamboo 1000000,1 -t -np
DELETING UNREACHABLE STATES...
MINIMIZATION STARTED...
MINIMIZATION FINISHED SUCCESSFULLY
999999 iterations happened
DFA UPDATED
It has 1000000 states now
Execution time: 3.6638 seconds.
\end{lstlisting}

\section{Анализ работы программы}

\subsection{Сравнение времени работы алгоритмов Хопкрофта и Мура}

Как уже было отмечено, алгоритм Хопкрофта работает на автоматах типа ``бамбук`` линейно от размеров автомата, а алгоритм Мура --- квадратично. Это было проверено на автоматах размеров $2^n$, $n \in \{10, \dots, 24\}$. Результаты измерений времени работы отражены в следующей таблице:

\setlength{\arrayrulewidth}{0.5mm}
\setlength{\tabcolsep}{18pt}
\begin{tabular}{|m{0.25\linewidth}|m{0.25\linewidth}|m{0.25\linewidth}|}
\hline
\centering Размер DFA типа bamboo & \centering Алгоритм Хопкрофта (сек.) &  Алгоритм Мура (сек.)\\
\hline
1024 & 0.000269 & 0.0010017 \\
\hline
2048 & 0.00087 & 0.0040186 \\
\hline
4096 & 0.001407 & 0.0155907 \\
\hline
8192 & 0.00277 & 0.0565663 \\
\hline
16384 & 0.004176 & 0.237831 \\
\hline
32768 & 0.008006 & 0.951994 \\
\hline
65536 & 0.014809 & 4.01016 \\
\hline
131072 & 0.029341 & 16.5476 \\
\hline
262144 & 0.058262 & 67.5289 \\
\hline
524288 & 0.120135 & 274.041 \\
\hline
1048576 & 0.235781 & -- \\
\hline
2097152 & 0.469479 & -- \\
\hline
4194304 & 0.953751 & -- \\
\hline
8388607 & 1.97026 & -- \\
\hline
\end{tabular}

\begin{center}
\begin{tikzpicture}
\begin{axis}[
    title={Соотношение времени работы алгоритмов Мура и Хопкрофта на автоматах типа ``бамбук``.},
    xlabel={Размер DFA},
    ylabel={Время в секундах},
    xmin=0, xmax=600000,
    ymin=0, ymax=300,
    xtick={262144, 524288},
    ytick={0,50,100,150,200,250,300},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]

\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (1024,0.0010017)(2048,0.0040186)(4096,0.0155907)(8192,0.0565663)(16384,0.237831)(32768,0.951994)(65536,4.01016)(131072,16.5476)(262144,67.5289)(524288,274.041)
    };
    \addlegendentry{алг. Мура}


\addplot[
    color=red,
    mark=square,
    ]
    coordinates {
    (1024,0.000269)
    (2048,0.00087)
    (4096,0.001407)
    (8192,0.00277)
    (16384,0.004176)
    (32768,0.008006)
    (65536,0.014809)
    (131072,0.029341)
    (262144,0.058262)
    (524288,0.120135)
    };
    \addlegendentry{алг. Хопкрофта}
    
\end{axis}
\end{tikzpicture}
\end{center}

Также была исследована работа этих алгоритмов для минимизации DFA для языка, задающего все слова над алфавитом $\{a, b\}$, у которых $(n - 1)$-ый символ с конца равен $a$. Cтроился NFA, задающий этот язык, переводился в DFA, который затем минимизировался (как известно, в минимизированном DFA в таком случае будет не менее чем $2^{n-1}$ состояний). 


  \setlength{\arrayrulewidth}{0.5mm}
  \setlength{\tabcolsep}{18pt}
  \begin{tabular}{|m{0.25\linewidth}|m{0.25\linewidth}|m{0.25\linewidth}|}
  \hline
  \centering n & \centering Алгоритм Хопкрофта (сек.) &  Алгоритм Мура (сек.)\\
  \hline
  
  12 & 0.000747 & 0.0010522\\
  \hline
  13 & 0.001364 & 0.0017582\\
  \hline
  14 & 0.002397 & 0.0029991\\
  \hline
  15 & 0.00477 & 0.0049912\\
  \hline
  16 & 0.010971 & 0.0135385\\
  \hline
  17 & 0.023378 & 0.0270009\\
  \hline
  18 & 0.047164 & 0.0590049\\
  \hline
  19 & 0.115261 & 0.127855\\
  \hline
  20 & 0.302292 & 0.296526\\
  \hline
  21 & 0.672999 & 0.65721\\
  \hline
  22 & 1.43655 & 1.5208\\
  \hline
  23 & 3.25043 & 3.84943\\
  \hline
  24 & 6.82125 & 8.92102\\
  \hline
  25 & 13.5632 & 18.8834\\
  \hline
  26 & 27.5825 & 40.6004\\
  \hline
  27 & 59.4406 & -- \\
  \hline
  \end{tabular}
  \begin{center}
  Сравнение работы алгоритмов минимизации автоматов, имеющих $2^{n-1}$ состояний.
  \end{center}

При больших $n$ реализация алгоритма Хопкрофта опережает алгоритм Мура. Однако при этом алгоритм расходует намного больше памяти, нежели необходимо алгоритму Мура.

\subsection{Расходуемая память}

Для каждого состояния хранятся номер блока, в котором оно находится (4 байта), номер следующего и предыдущего состояний их того же самого блока (8 байт). Также для каждого символа $a \in \Sigma$ хранятся номер следующего и предыдущего состояний из этого же блока, которые достижимы по этому символу $a$ (если само состояние достижимо по символу $a$) --- то есть ещё $|\Sigma| \cdot 8$ байт. Для содержания состояния в $L(a)$ нужно $8 + 1/8$ байт (8 на само состояние и символ $a$, в случае если оно там лежит, и 1 бит показывающий, лежит ли оно в $L(a)$ или нет). Итого, ещё $|\Sigma| \cdot (8 + 1/8)$ байт. Для хранения правил $\delta$ нужно $|\Sigma| \cdot 4$ байта на состояние, и ещё 1 бит о том, принимается оно или отвергается.

Для каждого блока $B(j)$ (которых может быть от 1 до $n$) хранится количество состояний в нём, а также количество состояний в нём, достижимых по символу $a$ (для каждого $a \in \Sigma$) --- это $(|\Sigma| + 1) \cdot 4$ байт. И ещё хранятся $first(j)$ и $first(j, a)$ (для каждого $a \in \Sigma$) --- это ещё $(|\Sigma| + 1) \cdot 4$ байт.

Структуры \lstinline[language=C++]!addresses_for_reversed_delta! и \lstinline[language=C++]!reversed_delta! занимают по $|\Sigma| \cdot n \cdot 4$ байта.

Также каждое из полей класса \lstinline[language=C++]!class DFA!, отвечающих за одну итерацию минимизации, может достигать размера $n$ (поля \lstinline[language=C++]!sep_blocks!, \lstinline[language=C++]!sep_states!, \lstinline[language=C++]!blocks_info!). Они суммарно занимают не более $20 \cdot n$ байт. 

Итого, суммарно используется не более чем
\[(4 + 8 + |\Sigma| \cdot 8 + |\Sigma| \cdot (8 + 1/8) + |\Sigma| \cdot 4 + 1/8 + (|\Sigma| + 1) \cdot 4 \cdot 2 + |\Sigma| \cdot 4 \cdot 2+ 20) \cdot n = (40 + 1/8 + |\Sigma| \cdot (36 + 1/8)) \cdot n \ \text{байт,}\]
где $n$ --- число состояний в исходном DFA.
\section{Заключение}
Исследована статья Джона Хопкрофта \cite{hopcroft1971n}, в которой описан этот алгоритм.

Разобрана работа алгоритма Хопкрофта, доказаны утверждения о его корректности и асимптотике, написана программа, минимизирующая входной DFA, пользуясь этим алгоритмом. Поставленная задача выполнена.

Также планируется добавить дополнительную операцию инициализации DFA --- \lstinline[language=bash]!shift! (циклический сдвиг) --- получение нового автомата из какого-то путём циклического сдвига. Это преобразование описано в статье \cite{shift2008}, с которой я на данный момент разбираюсь.
\bibliographystyle{plain}
\bibliography{hopcroft}
\end{document}
